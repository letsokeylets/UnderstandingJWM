public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }

}

/**
 * 1. Изначально произойдёт загрузка классов через подсистему загрузчика классов.
 * Так как класс не из библиотек и не подгружаемый через средства сборки проекта - сработает Application ClassLoader
 * который подгружает классы созданные нами в нашем проекте
 * 2. После подгрузки класса происходит проверка на валидность кода, подготовка статических полей и примитивов, связывание ссылок.
 * 3. Происходит инициализация. Выполняются static инициализаторы и инициализаторы static полей.
 * (Наш класс подгружается в область памяти Metaspace вместе с static полями).
 * 4. После инициализации создаётся стек (в памяти Stack Memory) куда первым фреймом заносится вызов метода main().
 * 5. В этот фрейм кладётся примитив из строки кода (1) int "i" = 1
 * 6. Далее по строчке (2) в куче создаётся объект типа Object а в фрейм (main()) кладётся ссылка на этот объект - "o".
 * 7. По строчке (3) в фрейм (main()) создаётся ссылка "ii",
 * которая будет ссылаться на только что созданный объект типа Integer в куче (Heap в памяти) со значением "2"
 * 8. По строчке (4) происходит вызов метода. В этот момент в стеке создаётся новый фрейм printAll()
 * в этом фрейме создаётся новая ссылка "o", которая ссылается на тот же Object, что и ссылка из предыдущего фрейма,
 * создаётся новая ссылка "ii", которая ссылается на тот же Integer со значением "2", что и ссылка из предыдущего фрейма,
 * создаётся новый примитив типа int - "i" со значением "1"
 * 9. Далее отрабатывает строка кода (5). По ней в фрейме printAll() создаётся новая ссылка
 * "uselessVar" и в куче создаётся новый объект, на который ссылается наша ссылка из фрейма, типа Integer со значением "700"
 * 10. По строчке (6) произойдёт создание нового фрейма println() куда занесётся примитив "i", ссылка "o" из предыдущего фрейма,
 * и ссылка "ii", также из предыдущего фрейма
 * 11. По строчке (7). Когда метод перейдёт к этому пункту, из фрейма удалится вызов последних 2 стеков (println() и printAll() в таком порядке)
 * После чего создаться новый фрейм println() в нём (исходя из источников) создаться ссылка "х",
 * которая будет ссылаться на новый объект в куче с типом String и значением "finished".
 * Так как printAll() удалён из фрейма, с ним удалилась и уникальная ссылка "uselessVar", после этого сборщик мусора из кучи (Heap) скорее всего удалит
 * объект, на который ссылалась эта ссылка, а именно объект Integer со значением 700, так как он никогда не будет использован
 * 12. После выполнения последней строчки произойдёт поочерёдное удаление фреймов println() и main(), сборщиком мусора во время
 * исполнения команды будут постепенно удалятся те объекты, на которые больше не будет ссылок. Исходя из этого, после закрытия фреймов
 * сборщик мусора зачистит все объекты в куче, так как на них нет больше ссылок.
 * Следовательно работа программы завершится
 */